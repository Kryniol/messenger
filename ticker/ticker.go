package ticker

import (
	"context"
	"github.com/riid/messenger"
	"github.com/riid/messenger/envelope"
	"time"
)

const tickerNameHeader = "X-Ticker-Name"

// New returns a messenger.Receiver that generates messenger.Envelope on every tick of the *time.Ticker.
// Each envelope will contain the time.Time of the tick.
// The receiver also implements messenger.Matcher that matches envelopes that generated by it.
// For matching events it uses the name parameter.
func New(t *time.Ticker, name string) *ticker {
	return &ticker{
		ticker: t,
		name:   name,
	}
}

type ticker struct {
	ticker *time.Ticker
	name   string
}

func (t *ticker) Ack(ctx context.Context, e messenger.Envelope) error {
	return nil
}

func (t *ticker) Nack(ctx context.Context, e messenger.Envelope) error {
	return nil
}

// Matches returns true if the envelope have ticker name in the header
func (t *ticker) Matches(e messenger.Envelope) bool {
	name, found := e.LastHeader(tickerNameHeader)
	return found && name == t.name
}

// Receive returns a channel where it pushes envelopes with current time on each tick of the time.Ticker
// Closes the channel when context.Context is done
func (t *ticker) Receive(ctx context.Context) (<-chan messenger.Envelope, error) {
	ec := make(chan messenger.Envelope)

	go func() {
		defer close(ec)
	loop:
		for {
			select {
			case <-ctx.Done():
				break loop
			case tick := <-t.ticker.C:
				ec <- envelope.WithHeader(envelope.FromMessage(tick), tickerNameHeader, t.name)
			}
		}
	}()

	return ec, nil
}
